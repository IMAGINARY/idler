import{performance as t}from"universal-perf-hooks";import{EventEmitter as e}from"events";const s=setTimeout(()=>{},0);class i{constructor(t,e,i,r,...h){this.timeoutId=s,this.idle=t,this.repeat=e,this.func=i,this.timeoutDelay=r,this.args=h,this.testTimeoutCb=()=>this.testTimeout(),this.testTimeout()}reset(){clearTimeout(this.timeoutId),this.timeoutId=setTimeout(this.testTimeoutCb,this.timeoutDelay)}clear(){clearTimeout(this.timeoutId)}testTimeout(){const t=this.idle.getIdleTime();t>=this.timeoutDelay?(this.repeat&&this.reset(),this.func(...this.args)):this.timeoutId=setTimeout(this.testTimeoutCb,this.timeoutDelay-t)}}function r(){return t.now()}class h extends e{constructor(){super(),this.lastId=0,this.timers=new Map,this.lastEventTimestampMs=r()}setTimeout(t,e,...s){this.lastId+=1;const r=this.lastId;return this.timers.set(r,new i(this,!1,t,e,...s)),r}setInterval(t,e,...s){this.lastId+=1;const r=this.lastId;return this.timers.set(r,new i(this,!0,t,e,...s)),r}clearTimeout(t){const e=this.timers.get(t);void 0!==e&&e.clear(),this.timers.delete(t)}clearInterval(t){this.clearTimeout(t)}clear(){this.timers.forEach(t=>t.clear()),this.timers.clear()}interrupt(){this.lastEventTimestampMs=Math.max(r(),this.lastEventTimestampMs),this.emit("interrupted")}getIdleTime(){return r()-this.lastEventTimestampMs}}export{h as Idler};
//# sourceMappingURL=idler.modern.js.map
